Прототип — это порождающий паттерн проектирования, который позволяет копировать объекты,
не вдаваясь в подробности их реализации.

________________________________________________________________________________________________________________________
Преимущества:
1.Позволяет клонировать объекты, не привязываясь к их конкретным классам.
2.Меньше повторяющегося кода инициализации объектов.
3.Ускоряет создание объектов.
4.Альтернатива созданию подклассов для конструирования сложных объектов.
________________________________________________________________________________________________________________________
Недостатки:
1.Сложно клонировать составные объекты, имеющие ссылки на другие объекты.
________________________________________________________________________________________________________________________
Шаги реализации:
1.Создайте интерфейс прототипов с единственным методом clone. Если у вас уже есть иерархия продуктов,
метод клонирования можно объявить непосредственно в каждом из её классов.
2.Добавьте в классы будущих прототипов альтернативный конструктор, принимающий в качестве аргумента объект текущего класса.
Этот конструктор должен скопировать из поданного объекта значения всех полей, объявленных в рамках текущего класса,
а затем передать выполнение родительскому конструктору, чтобы тот позаботился о полях, объявленных в суперклассе.
3.Если язык программирования не поддерживает перегрузку методов, то вам не удастся создать несколько версий конструктора.
В этом случае копирование значений можно проводить и в другом методе, специально созданном для этих целей.
Конструктор удобнее тем, что позволяет клонировать объект за один вызов.
4.Метод клонирования обычно состоит всего из одной строки: вызова оператора new с конструктором прототипа.
Все классы, поддерживающие клонирование, должны явно определить метод clone, чтобы использовать собственный класс с оператором new.
В обратном случае результатом клонирования станет объект родительского класса.
5.Опционально, создайте центральное хранилище прототипов. В нём удобно хранить вариации объектов, возможно,
даже одного класса, но по-разному настроенных.
6.Вы можете разместить это хранилище либо в новом фабричном классе, либо в фабричном методе базового класса прототипов.
Такой фабричный метод должен на основании входящих аргументов искать в хранилище прототипов подходящий экземпляр,
а затем вызывать его метод клонирования и возвращать полученный объект.
7.Наконец, нужно избавиться от прямых вызовов конструкторов объектов,
заменив их вызовами фабричного метода хранилища прототипов.